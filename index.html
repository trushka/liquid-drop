<!DOCTYPE html>
<html lang="en">
<head>
	<title>Morphing drop</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
		  color: #fff;
		  font-family: Monospace;
		  font-size: 13px;
		  text-align: center;

		  background-color: #000;
		  margin: 0px;
		  overflow: hidden;
		}

		#info {
		  color: #ffffff;
		  position: absolute;
		  top: 0px;
		  width: 100%;
		  padding: 5px;
		}

		a {
		  color: gold;
		}

		#webglmessage {
		  font-family: monospace;
		  font-size: 13px;

		  text-align: center;
		  background: rgb(0, 0, 50);
		  color: #fff;
		  padding: 1em;

		  width: 475px;
		  margin: 5em auto 0;

		  display: none;
		}
	</style>
</head>

<body>

	<div id="container"></div>
	
	<div id="info">
		<a href="https://github.com/trushka/liquid-drop">github.com/trushka/liquid-drop</a>
	</div>

	<script src="three.min.js"></script>

	<script src="TrackballControls.js"></script>

	<script src="MarchingCubes.js"></script>

	<script>

		var envSrc="windows.jpg";
		var resolution = 30, isolation = 40, subtract = 3, strength=1.82,
			speed = 3/5000, delta=.15, amplitude = .76, roV = .0003;

		var targGeometry=new THREE.TetrahedronGeometry();

		var t0 = Date.now(), dMax = 80, dMin = 1000/60, dT = 1000/50

		var container;

		var camera, controls, scene, renderer;

		var material, envMap;

		var effect;

		var time = 0;

		init();
		requestAnimationFrame( animate );

		function init() {

			container = document.getElementById( 'container' );

			// CAMERA

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.set( 0, 0, 1500 );

			// SCENE

			scene = new THREE.Scene();

			// MATERIALS

			THREE.ShaderChunk.envmap_fragment=THREE.ShaderChunk.envmap_fragment.replace(
				'sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;',
				'sampleUV.x = asin( reflectVec.z / length(reflectVec.xz) ) * RECIPROCAL_PI2 + 0.5;'
			);
			envMap = new THREE.TextureLoader().load(envSrc);
			envMap.mapping = THREE.EquirectangularReflectionMapping;
			envMap.encoding=THREE.GammaEncoding;
			material = new THREE.MeshPhongMaterial( { emissive: 0xffffff, envMap: envMap } );

			// MARCHING CUBES

			effect = new THREE.MarchingCubes( resolution, material, true, true );
			// effect.position.set( -450, -450, -450 );
			effect.scale.multiplyScalar( 500 );
			scene.add( effect );

			effect.enableUvs = false;
			effect.enableColors = false;
			effect.init( Math.floor( resolution ) );
			effect.isolation = isolation;


			// RENDERER

			renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
			renderer.gammaOutput = true;
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );

			renderer.domElement.style.position = "absolute";
			renderer.domElement.style.top = "0px";
			renderer.domElement.style.left = "0px";

			container.appendChild( renderer.domElement );

			// CONTROLS

			controls = new THREE.TrackballControls( camera, renderer.domElement );
			Object.assign(controls, {
				staticMoving: false,
				rotateSpeed: 3
			})

			window.addEventListener( 'resize', onWindowResize, false );

		}

		//

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );

		}

		// this controls content of marching cubes voxel field

		function updateCubes( object, time ) {

			object.reset();

			var vertices = targGeometry.vertices, numblobs = vertices.length;
			//var strength = 1.2 / ( ( Math.sqrt( numblobs ) - 1 ) / 4 + 1 );

			for ( var i = 0; i < numblobs; i ++ ) {

				time+=delta;

				phase=Math.sin(time + .2 + .2*Math.sin(time*2))/2*amplitude;

				ballx = vertices[i].x * phase + .5;
				bally = vertices[i].y * phase + .5;
				ballz = vertices[i].z * phase + .5;

				object.addBall( ballx, bally, ballz, strength, subtract );
			}
		}

		//

		function animate() {

			requestAnimationFrame( animate );

			render();

		}

		function render() {

			var t = Date.now(), dt = t-t0;
			if (dt<dMin) return; // !Eh || 
			dt = Math.min(dt, dMax);
			t0 = t;

			time += dt * speed;

			// marching cubes

			effect.rotateY(dt*roV);
			updateCubes( effect, time );

			controls.update();

			renderer.render( scene, camera );

		}

</script>

</body>
</html>
